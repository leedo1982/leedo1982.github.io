---
layout  : wiki
title   : Mysql 의 주요 처리 방식
summary : 
date    : 2020-12-27 09:07:36 +0900
updated : 2020-12-29 07:30:03 +0900
tag     : 
toc     : true
public  : true
parent  : [[REAL_MYSQL]]
latex   : false
---
* TOC
{:toc}

# 개요  
  설명하는 내용중에 풀테이블 스캔을 제외한 나머지는 모두 스토리지 엔진이 아니라 Mysql 엔진에서 처리되는 내용이다. 또한 Mysql 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 미치는 영향력이 큰데, 안타깝게도 모두 쿼리의 성능을 저하시키는 데 한몫하는 작업이다. 처리하는데 오래 걸리는 작업의 원리를 알아 둔다면 쿼리를 튜닝하는데 상당히 많은 도움이 될 것이다. 
  
# 6.3.1 풀테이블 스캔  
인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.  
다음 조건일 때 주로 Mysql 옵티마이저는 선택한다.  
- 테이블의 레코드 건수가 너무 작아서 인덱스틑 통해 읽는 것보다 풀텡블 스캔을 하는 편이 더 빠른경우
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- 반대로, max_seeks_for_key 변수를 특정 값으로 설정하면 Mysql 옵티마이저는 인덱스의 기수성이나 선택도를 무시하고, 최대N 건만 읽으면 된다고 판단하게 된다. 이값을 작게 설정할수록 Mysql 서버가 인덱스를 더 사용하도록 유도함. 
  
  
# 6.3.2 ORDER BY 처리(Using filesort)
정렬을 처리하기 위해서는 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.  

| 구분          | 장점                                                                                      | 단점                                                                                        |
|---------------|-------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|
| 인덱스를 이용 | I,U,D 쿼리가 실행될때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우빠르다. | I,U,D 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.                            |
| FileSort 이용 | 인덱스를 생성하지 않으므로 인덱스의 단점이 장정으로 바뀐다.                               | 정렬 작업이 쿼리 실행시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다. |

물론 레코드 정렬하기 위해 항상 "Filesort"라는 정렬 작업을 거쳐야 하는 것은 아니다. Mysql 이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행계획의 Extra 칼럼에 "Using filesort" 라는 코멘트가 표시되는지로 판단할 수 있다. 

## 소트버퍼 (Sort buffer)
정렬을 수행하기 위해 별도의 메모리 공간을 할당 받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.

## 정렬 알고리즘
레코드를 정렬할 때, 레코드 전체를 소트 버퍼에 담을지 또는 정렬기준 칼럼만 소트버퍼에 당을지에 따라 2가지 알고리즘으로 나눠 볼수 있다.

### 싱글패스 알고리즘 
소트버퍼에 정렬 기준 칼럼을 포함해 SELECT 되는 칼럼 전부를 담아서 정렬을 수행하는 방법. 정렬이 완료 되면 버퍼의 내용을 그대로 클라이언트로 넘겨준다. 

### 투패스 알고리즘
정렬 대상 칼럼과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 ㄷ시 프라이머리 키로 테이블을 읽어서 SELECT 할 칼럼을 가져오는 알고리즘으로 예전 Mysql 에서 사용하던 방법이다.

다음과 같은 때 사용된다. 
- 레코드의 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클때
- BLOB 이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할때 


## 정렬의 처리방식 
쿼리에 order by 가 사용되면 반드시 다음 3가지 처리 방식 중 하나로 정렬이 처리된다. 일반적으로 밑쪽에 있는 정렬방법으로 갌록 처리가 느려진다.
- 인덱스 사용한 정렬 : 별도의 내용표기 없음
- 드라이빙 테이블만 정렬(조인이 없는 경우 포함 ) : "Using filesort" 가 표시됨
- 조인 결과를 임시 테이블로 저장한 후 임시테이블에서 정렬 : "Using temporary; Using filesort"가 같이 표시됨


### 인덱스를 이용한 정렬
인덱스를 이용한 정렬을 위해서는 반드시 order by 에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고, order by 의 순서대로 생성된 인덱스가 있어야 한다. 또한 첫번째 읽는 테이블의 칼러에 대한 조건이 있다면 그 조건과 order by는 같은 인덱스를 사용할 수 있어야 한다. 그리고 B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다. 예외적으로 R-Tree 도 B-Tree 계열이지만 특성상 이 방식을 사용할 수 없다. 여러 테이블이 조인되는 경우에는 네스티드루프(Nested-loop) 방식의 조인에서만 이 방식을 사용할 수 있다. 

### 드라이빙 테이블만 정렬
일반 적으로 조인이 수행되면 결과 레코드의 건수가 몇배로 불어난다. 그래서 조인을 실행하기 전에 첫번째 테이블의 레코를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이 될 것이다. 이 방법은 조인에서 첫번째 읽히는 테이블의 칼럼만으로 order by 절이 작성되야 한다.

### 임시 테이블을 이용한 정렬
쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT 해서 정렬하는 경우라면 임시 테이블이 필요하지 않다. 하지만 2개 이상의 테이블을 조이해서 그 결과를 정렬해야 한다면 임시테이블이 필요할 수도 있다.  위에서 살펴본 "드라이빙 테이블만 정렬" 은 2개이상의 테이블이 조인되면서 정렬이 싱행되지만 임시테이블을 사용하지 않는다.


# 6.3.3. GROUP BY 처리
